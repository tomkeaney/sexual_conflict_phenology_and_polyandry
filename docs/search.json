[
  {
    "objectID": "numeric_model.html",
    "href": "numeric_model.html",
    "title": "The numeric model",
    "section": "",
    "text": "Code\nlibrary(tidyverse)\nlibrary(stickylabeller)\nlibrary(MoMAColors)"
  },
  {
    "objectID": "numeric_model.html#general-points",
    "href": "numeric_model.html#general-points",
    "title": "The numeric model",
    "section": "General points",
    "text": "General points\n\nWe assume continuous time, where emergence, mating and death can occur at any real value of t within a generation.\nKawanaphila nartee has an annual lifecycle, where offspring eclose in early spring and all adults die in the summer, making generations discrete.\nFitness is the cumulative number of offspring that survive to breeding age in the next generation (think on this).\nDensities of females and males vary continuously\nThe model considers a temporally and/or spatially varying resource that determines reproductive success from mating at a specific time. For example, females entering the mating pool just as grass trees flower have plenty of resources and high fecundity. Those females entering the mating pool during the kangaroo paw flowering have less resources and lower fecundity. The same argument extends to whether females mature on kangaroo paws or grass trees. But this isn’t a timing problem so we can put it to one side for now.\nMales can become sperm/spermatophore depleted. The amount of time they spend replenishing their spermatophore depends on local resource abundance. Males grow their spermatophores to a max size (which individually varies and has proxies which females use to choose/ focus their competition potential mating partners).\nThe numeric model can be solved to find the hypothetical timing traits that maximise population fitness or the solutions predicted to occur when the sexes coevolve."
  },
  {
    "objectID": "numeric_model.html#lifecycle",
    "href": "numeric_model.html#lifecycle",
    "title": "The numeric model",
    "section": "Lifecycle",
    "text": "Lifecycle\n\nCo-evolving traits \\(T_\\mathrm{F}\\) and \\(T_\\mathrm{M}\\) for female and male emergence/development times (these are quantitative characters - genotypic values).\nAvailable individuals form mating pairs using mass-action law (closer term to our field is fertilisation kinetics). That is, the population-wide rate of mating pairs forming at any t is proportional to the product of male and female densities at time t, multiplied with a constant v that characterises male search efficiency.\nIndividuals are available as mates if they have emerged, are alive and not in time-out. For males, time-out is determined by the length of time taken to replenish their spermatophore, which depends in part on the abundance of resources available. For females, time-out is determined by the resources at their disposable at mating time, t. The closer they are to the resource peak, the slower they return to the mating pool. Each indirectly depends on the abundance of resources available immediately following mating.\nAt the resource peak, there is no benefit to females mating more than once.\n\n\nEmergence\nIndividuals with trait values \\(T_\\mathrm{F}\\) or \\(T_\\mathrm{M}\\) display an emergence distribution governed by the equations\n\\[E_\\mathrm{F}(t, T_\\mathrm{F}) = \\frac{e^{t-T_\\mathrm{F}}}{(1 + e^{t - T_\\mathrm{F}})^2} \\tag{1}\\]\n\\[E_\\mathrm{M}(t, T_\\mathrm{M}) = \\frac{e^{t-T_\\mathrm{M}}}{(1 + e^{t - T_\\mathrm{M}})^2} \\tag{2}\\]\nfollowing Zonnevald and Metz (1991) and Ekrem and Kokko (2023).\n\\(E_\\mathrm{F}(t, T_\\mathrm{F})\\) and \\(E_\\mathrm{M}(t, T_\\mathrm{M})\\) are the numbers of females and males emerging at time t.\nI understand how equations work a lot better after plotting them. For some values of t and \\(T_i\\) let’s see what this function looks like.\n\n\nCode\n  expand_grid(t = seq(from = -8, to = 8, by = 0.01),\n              T_i = runif(50, min = -2, max = 2)) %&gt;% \n  mutate(Emergence = exp(t - T_i)/(1 + exp(t - T_i))^2) %&gt;% \n  \n  ggplot(aes(x = t, y = Emergence)) +\n  geom_line(aes(group = T_i, colour = T_i), alpha = 0.8) +\n  #scale_color_gradientn(colors=moma.colors(\"Alkalay2\", n =5, override_order = TRUE)) +\n  scale_color_gradientn(colors=moma.colors(\"Exter\", n =5, override_order = TRUE)) +\n  labs(y = \"Prop. individuals emerging/arriving\",\n       x = \"Time, t\",\n       colour = \"Timing genotypic value\") +\n  theme_minimal() +\n  theme(axis.title = element_text(size = 14))\n\n\n\n\n\n\n\n\n\n\n\nCode\n# shinylive-r\n\n# Load required libraries\nlibrary(shiny)\nlibrary(dplyr)\nlibrary(ggplot2)\n\n# Define the UI\nui &lt;- fluidPage(\n\n  titlePanel(\n    div(style = \"text-align: center;\", \n        \"Emergence time\")\n  ),\n  \n  # Create a layout with the plot and slider stacked vertically\n  fluidRow(\n    # Plot in the top row\n    column(12, \n           plotOutput(\"plot\"))\n  ),\n  \n  fluidRow(\n    # Slider in the row below the plot\n    column(12, \n           div(style = \"display: flex; justify-content: center;\",\n               sliderInput(\"T_value\", \n                           label = \"Genotypic value\", \n                           min = -2, \n                           max = 2,\n                           step = 0.2,  # Step size for finer adjustments\n                           value = 0))  # Default value for T_i\n    )\n  )\n)\n# Define the Server function\nserver &lt;- function(input, output) {\n  \n  # Reactive expression to calculate the necessary data based on T_i\n  reactive_data &lt;- reactive({\n    # Let's assume your original code is something like this\n    T_i &lt;- input$T_value\n    \n    # Sample computation, replace this with your own calculation\n    data &lt;- tibble(t = seq(from = -8, to = 8, by = 0.01)) %&gt;% \n  mutate(Emergence = exp(t - T_i)/(1 + exp(t - T_i))^2) \n    \n    \n    \n    return(data)\n  })\n  \n  # Plot output based on the reactive data\n  output$plot &lt;- renderPlot({\n    data &lt;- reactive_data()\n    \n    # Create a plot based on the reactive data\n    data %&gt;% \n      ggplot(aes(x = t, y = Emergence)) +\n      geom_line(alpha = 0.8, linewidth = 1.4, colour = \"#d9402a\") +\n      #scale_color_gradientn(colors=moma.colors(\"Exter\", n =5, override_order = TRUE)) +\n      labs(y = \"Prop. individuals emerging/arriving\",\n           x = \"Time, t\") +\n      scale_x_continuous(breaks = seq(-8, 8, by = 5)) +  # Set x-axis ticks and labels\n      scale_y_continuous(breaks = seq(0, 0.25, by = 0.05)) +\n      theme_minimal() +\n      theme(axis.title = element_text(size = 20))\n\n  })\n}\n\n# Run the Shiny app\nshinyApp(ui = ui, server = server)\n\n\n\n\nTracking mating and death\nMating dynamics are followed over one breeding season. The sexes encounter one another with search efficiency \\(v\\), where higher values indicate efficient mate finding. Males die with rate \\(\\mu_\\mathrm{M}\\) and females with rate \\(\\mu_\\mathrm{F}\\).\n\n\n\n\n\n\nAlternative thought: Sperm limitation\n\n\n\nEkrem and Kokko (2023) consider a population where a male can become sperm-limited. Should we use a similar approach? Sperm-limitation (imposes sexual selection on females) and the constraints imposed by the spermatophore (imposes natural selection on females) are separate processes producing mate limitation for females. Whether sperm-limitation ever matters in this species is a matter for debate.\n\n\nHere, I write equations to describe the structure of the adult population following a time-in, time-out mating framework. Females arrive in the time-in state and once mated move to the time-out state. Males require resources to produce a spermatophore and therefore arrive in the time-out state. The sexes then have specific rates – \\(\\delta_\\mathrm{F}(t)\\) and \\(\\delta_\\mathrm{M}(t)\\) – at which they transition back into the mating pool. These rates depend on the amount of resources available at the time of the just-completed mating. Males return to the mating pool at rate\n\\[\\delta_\\mathrm{M}(t) = \\frac{x_\\mathrm{M}e^{t/L}}{(1 + e^{t/L})^2} \\tag{3}\\] where the variable \\(L\\) determines the length of the season. When \\(L\\) is small, reproductive success declines quickly as the temporal mismatch with the resource peak increases. Refactory periods are lowest when resource availability is high. If mating occurs at the resource peak, the rate of re-entering the mating pool is \\(x_\\mathrm{M}e^0/(1 + e^0)^2 = \\frac{x_\\mathrm{M}}{4}\\), where \\(x_\\mathrm{M}\\) determines the efficiency of spermatophore regeneration across the population, or in other words, the maximum rate of return to the mating pool. The length of the refractory period for females is governed by the rate\n\\[\n\\delta_\\mathrm{F}(t) = \\frac{x_\\mathrm{F}}{4} -\n\\frac{x_\\mathrm{F}e^{t/L}}{(1 + e^{t/L})^2} -\n\\alpha(\\frac{x_\\mathrm{F}}{4} - \\frac{x_\\mathrm{F}e^{t/L}}{(1 + e^{t/L})^2})\n\\tag{4}\\]\nwhere \\(x_\\mathrm{F}\\) determines the efficiency of oogenesis for a given resource abundance, or, once again, the maximum rate of return to the time-in state. The second term in Equation 4 captures the decline in the rate of return to the mating pool caused by greater parental attributed to resources gathered from the environment. The third term is the reduction in the rate of return caused by greater parental expenditure achieved by consuming a spermatophore during mating, where controls the nutritional value of the spermatophore. When resources are scarce, females can provision fewer eggs and therefore return to the mating pool at a higher rate. As resources become abundant, females can provision more eggs, increasing the amount of time they spend out of the mating pool egg laying. Male and female refractory periods thus plastically respond in exactly opposite ways to resource abundance at the time a mating is completed.\nWhen \\(x_\\mathrm{F} = x_\\mathrm{M} = 1\\), \\(L = 1\\) and spermatophores have no nutritional value (\\(\\alpha\\) = 0), rates of return to the mating pool are distributed across time like so:\n\n\nCode\n  expand_grid(t = seq(from = -8, to = 8, by = 0.01),\n              x = 1) %&gt;% \n  mutate(Males = x*exp(t)/(1 + exp(t))^2,\n         Females = x/4 - x*exp(t)/(1 + exp(t))^2) %&gt;% \n  pivot_longer(cols = 3:4, values_to = \"Rate of return to mating pool\", names_to = \"Sex\") %&gt;% \n  ggplot(aes(x = t, y = `Rate of return to mating pool`)) +\n  geom_line(alpha = 1, linewidth = 1.2) +\n  labs(y = \"Rate of return to mating pool\",\n       x = \"Time, t\",\n       colour = \"Timing trait value\") +\n  facet_wrap(~Sex) +\n  theme_minimal() +\n  theme(strip.text = element_text(size = 14),\n        axis.title = element_text(size = 14))\n\n\n\n\n\n\n\n\n\nIf spermatophores have nutritional value, \\(\\delta_\\mathrm{F}\\) looks like this:\n\n\nCode\n  expand_grid(t = seq(from = -8, to = 8, by = 0.01),\n              x = 1,\n              a = c(0, 0.25, 0.5, 1),\n              L = 1) %&gt;% \n  mutate(Females = x/4 - x*exp(t)/(1 + exp(t))^2 - (a * (x/4 - (x*exp(t / L)/(1 + exp(t / L))^2)))) %&gt;% \n  #pivot_longer(cols = 5, values_to = \"Rate of return to mating pool\", names_to = \"Sex\") %&gt;% \n  ggplot(aes(x = t, y = Females)) +\n  geom_line(alpha = 1, linewidth = 1.2) +\n  labs(y = \"Rate of return to mating pool\",\n       x = \"Time, t\",\n       colour = \"Timing trait value\") +\n    facet_wrap(~a, nrow = 2, labeller = label_glue(paste0(expression(alpha), \" = {a}\"))) +\n  theme_minimal() +\n  theme(strip.text = element_text(size = 14),\n        axis.title = element_text(size = 14))\n\n\n\n\n\n\n\n\n\nWith terms to govern dynamic potential mating rates for both sexes, we now need a set of equations which describe the frequency of individuals in each mating state at time \\(t\\). Let \\(f_0\\) and \\(m_0\\) equal the number of mature females and males that are receptive to mating (in time-in), respectively. \\(f_1\\) and \\(m_1\\) represent the number of mature females and males that are unreceptive to mating (in time-out).\n\\[\\begin{equation}\n\\left\\{\n\\begin{aligned}\n\\frac{df_0}{dt} &= E_\\mathrm{F}(t, T_\\mathrm{F}) -vm_0(t)f_0(t) - \\mu_\\mathrm{F}f_0(t) + \\delta_\\mathrm{F}f_1(t) \\\\\n\n\\frac{df_1}{dt} &= vm_0(t)f_0(t) - \\mu_\\mathrm{F}f_1(t) - \\delta_\\mathrm{F}f_1(t) \\\\\n\n\\frac{dm_0}{dt} &= -vm_0(t)f_0(t) - \\mu_\\mathrm{M}m_0(t) + \\delta_\\mathrm{M}(t)m_1(t) \\\\\n\n\\frac{dm_1}{dt} &= E_\\mathrm{M}(t, T_\\mathrm{M}) + vm_0(t)f_0(t) - \\mu_\\mathrm{M}m_1(t) - \\delta_\\mathrm{M}(t)m_1(t)\n\\end{aligned} \\right.\n\\end{equation}\\]{#eq-dynamics}"
  },
  {
    "objectID": "numeric_model.html#reproductive-success",
    "href": "numeric_model.html#reproductive-success",
    "title": "The numeric model",
    "section": "Reproductive success",
    "text": "Reproductive success\n\nTemporally defined seasons\nResources become available at some time before \\(t = 0\\), resource abundance peaks at \\(t = 0\\) and resources decline thereafter.\n\n\n\n\n\n\nNote\n\n\n\nThe decline in resource abundance is not so relevant for K. nartee, as the first heatwave of the warm months kills most to all adults. At this time, resource abundance is usually still high. Nevertheless this is an inherently unpredictable event, so some bet-hedging might be involved here.\n\n\nFollowing Ekrem and Kokko (2023), we model reproductive success, \\(R(t)\\), using the same functional form for the environment as for the emergence time and refractory period distributions defined above. We write reproductive success after mating at time \\(t\\) as\n\\[R(t) = \\frac{x_\\mathrm{F}e^{t/L}}{(1 + e^{t/L})^2}\\] If we set \\(x_\\mathrm{F} = 400\\), reproductive output across the season looks like this:\n\n\nCode\n  expand_grid(t = seq(from = -10, to = 10, by = 0.01),\n              L = runif(10, 0, 2)) %&gt;% \n  mutate(`Reproductive output` = 400*exp(t / L)/(1 + exp(t / L))^2) %&gt;% \n  \n  ggplot(aes(x = t, y = `Reproductive output`)) +\n  geom_line(aes(group = L, colour = L), linewidth = 1) +\n  scale_color_gradientn(colors=moma.colors(\"Exter\", n =5, override_order = TRUE)) +\n  coord_cartesian(xlim = c(-10, 10)) +\n  labs(y = \"Reproductive output\",\n       x = \"Time, t\",\n       colour = \"Length of season\") +\n  theme_minimal() +\n  theme(axis.title = element_text(size = 14))\n\n\n\n\n\n\n\n\n\n\n\nContext dependent spermatophore importance\nHowever, \\(R(t)\\) is also affected by the nutrient content of the spermatophore a female consumes during mating. With this in mind, reproductive success can be rewritten as\n\\[R(t) = \\frac{x_\\mathrm{F}e^{t/L}}{(1 + e^{t/L})^2} + \\alpha(\\frac{x_\\mathrm{F}}{4} - \\frac{x_\\mathrm{F}e^{t/L}}{(1 + e^{t/L})^2})\\]{#eq-repro},\nwhere the second term on the right hand side describes the importance of spermatophores as a resource at time \\(t\\). The \\(\\alpha\\) parameter controls the magnitude of fecundity increase attributed to the spermatophore, relative to resources available via other paths. If \\(\\alpha = 1\\) (note this is unrealistically large), each spermatophore consumed when no other resources are available provides the same benefit to fecundity as does timing reproduction perfectly with the temporal resource peak. The second term in the equation moderates the Bateman gradient such that the effect of resource availability on fecundity negatively correlates with the effect of spermatophore consumption on fecundity. When \\(t = 0\\) this second term equals zero i.e. there are no fecundity benefits from spermatophore ingestion.\nFor various values of \\(\\alpha\\) fecundity at time \\(t\\) becomes:\n\n\nCode\nexpand_grid(t = seq(from = -10, to = 10, by = 0.01),\n            L = runif(10, 0, 2),\n            a = seq(from = 0, to = 1, by = 0.1)) %&gt;% \n  mutate(`Reproductive output` = 400*exp(t / L)/(1 + exp(t / L))^2 +\n           (a * (100 - (400*exp(t / L)/(1 + exp(t / L))^2)))) %&gt;% \n  ggplot(aes(x = t, y = `Reproductive output`)) +\n  geom_line(aes(group = L, colour = L)) +\n    scale_color_gradientn(colors=moma.colors(\"Exter\", n =5, override_order = TRUE)) +\n  coord_cartesian(xlim = c(-10, 10)) +\n  facet_wrap(~a, nrow = 3, labeller = label_glue(paste0(expression(alpha), \" = {a}\"))) +\n  labs(y = \"Reproductive output\",\n       x = \"Time, t\",\n       colour = \"Length of season\") +\n  theme_minimal() +\n  theme(axis.title = element_text(size = 14))\n\n\n\n\n\n\n\n\n\nLet’s take a closer look at how varying \\(\\alpha\\) effects female egg production by setting \\(L = 1\\) and plotting reproductive output for different values of \\(\\alpha\\) on a single panel.\n\n\nCode\nexpand_grid(t = seq(from = -10, to = 10, by = 0.01),\n            L = 1,\n            a = seq(from = 0, to = 1, by = 0.1)) %&gt;% \n  mutate(`Reproductive output` = 400*exp(t / L)/(1 + exp(t / L))^2 +\n           (a * (100 - (400*exp(t / L)/(1 + exp(t / L))^2)))) %&gt;% \n  ggplot(aes(x = t, y = `Reproductive output`)) +\n  geom_line(aes(group = a, colour = a), linewidth = 1) +\n    scale_color_gradientn(colors=moma.colors(\"Exter\", n =5, override_order = TRUE)) +\n  coord_cartesian(xlim = c(-10, 10)) +\n  #facet_wrap(~a) +\n  #facet_wrap(~a, nrow = 3, labeller = label_glue(paste(expression(alpha), \" = {a}\"))) +\n  labs(y = \"Reproductive output\",\n       x = \"Time, t\",\n       colour = expression(alpha)) +\n  theme_minimal() +\n  theme(axis.title = element_text(size = 14))\n\n\n\n\n\n\n\n\n\n\n\nReproduction under polyandry\nImportantly, our model departs from that of Ekrem and Kokko (2023) in that we allow females to mate multiply, with each mating event followed by a bout of reproduction. The total reproductive success of a female that mates at least once is\n\\[W_\\mathrm{F} = \\sum_{i = 1}^{n}{R(\\mathrm{times}_i)}\\]{eq-f_fitness}\nwhere times is a vector of mating times with length \\(n\\).\n\n\n\n\n\n\nMale fitness\n\n\n\nMale fitness depends on whether we include sperm competition. At its simplest there is no sperm competition, and each female reproductive bout exclusively produces the progeny of the male she most recently mated with."
  },
  {
    "objectID": "simulation_cuts.html",
    "href": "simulation_cuts.html",
    "title": "Cuts",
    "section": "",
    "text": "Code\nrow &lt;- 1\nsex_limited &lt;- 1\nOSR_recording_interval &lt;- 0.5\n\n\nFew continuous loci inheritance\n\n\nCode\n  if(shared_loci &gt; 0){\n    fel &lt;-  c(\"locus_1a\", \"locus_1b\", \"locus_2a\", \"locus_2b\") # partially resolved sexual antagonism scenario\n    mel &lt;-  c(\"locus_1a\", \"locus_1b\", \"locus_3a\", \"locus_3b\")\n  } else{\n    fel &lt;-  c(\"locus_2a\", \"locus_2b\")\n    mel &lt;-  c(\"locus_3a\", \"locus_3b\")\n  }\n  \n# initialise the population\n# each generation fill the table with allelic values, emergence times and death times\n\n  population_attributes &lt;-\n    data.frame(sex = rbinom(popsize, 1, prob = 0.5), # 0 is female, +1 is male\n               locus_1a = rnorm(popsize, mean = 0, sd = 1), # shared locus parent 1 breeding value (bv)\n               locus_1b = rnorm(popsize, mean = 0, sd = 1), # shared locus parent 2 bv \n               locus_2a = rnorm(popsize, mean = 0, sd = 1), # female limited parent 1 bv\n               locus_2b = rnorm(popsize, mean = 0, sd = 1), # female limited parent 2 bv\n               locus_3a = rnorm(popsize, mean = 0, sd = 1), # male limited parent 1 bv \n               locus_3b = rnorm(popsize, mean = 0, sd = 1), # male limited parent 2 bv\n               state = Inf,\n               p = runif(popsize)) %&gt;% \n    # get breeding values\n    mutate(breeding_value = case_when(sex &gt; 0 & shared_loci &gt; 0 ~ (locus_1a + locus_1b + locus_3a + locus_3b)/4,\n                                      sex &lt; 1 & shared_loci &gt; 0 ~ (locus_1a + locus_1b + locus_2a + locus_2b)/4,\n                                      sex &gt; 0 & shared_loci &lt; 1 ~ (locus_3a + locus_3b)/2,\n                                      sex &lt; 1 & shared_loci &lt; 1 ~ (locus_2a + locus_2b)/2),\n           emergence_time = emergence_sample(breeding_value, p))\n\n\n\n\nCode\n  # initialise the population\n  # each generation fill the table with allelic values, emergence times and death times\n  pop &lt;-\n    data.table(sex = rbinom(popsize, 1, prob = 0.5), # 0 is female, +1 is male\n               locus_1a = rnorm(popsize, mean = 0, sd = 1), # shared locus parent 1 breeding value (bv)\n               locus_1b = rnorm(popsize, mean = 0, sd = 1), # shared locus parent 2 bv \n               locus_2a = rnorm(popsize, mean = 0, sd = 1), # female limited parent 1 bv\n               locus_2b = rnorm(popsize, mean = 0, sd = 1), # female limited parent 2 bv\n               locus_3a = rnorm(popsize, mean = 0, sd = 1), # male limited parent 1 bv \n               locus_3b = rnorm(popsize, mean = 0, sd = 1), # male limited parent 2 bv\n               state = Inf,\n               p = runif(popsize)\n    )[sex &gt; 0, breeding_value := rowMeans(.SD), .SDcols = mel # get male breeding values\n    ][sex &lt; 1, breeding_value := rowMeans(.SD), .SDcols = fel # get female breeding values\n    ][, emergence_time := emergence_sample(breeding_value, p) # everyone starts in 'timeout' bc they haven't arrived\n      ][ ,`:=`(locus_1a = NULL, # remove so sorting is faster during sim \n               locus_1b = NULL,\n               locus_2a = NULL, \n               locus_2b = NULL,\n               locus_3a = NULL, \n               locus_3b = NULL,\n               p = NULL,\n               breeding_value = NULL)]\n  \n  setorder(pop, emergence_time)[, ID := 1:popsize] # order by emergence time to make downstream operations faster, then set ID for each individual\n  \n  #total_time_out = rep(0, popsize))] # only relevant for females]\n  # for state - NaN: in mating pool, real number: time out with number indicating when they'll return, Inf: dead or yet to emerge\n  \n  # create empty array to hold female mating times \n  #adult_females &lt;- pop[pop$sex &lt; 1, \"ID\"] # females that survive density regulation\n  # we assume that females can't mate more than 20 times across the season\n  female_start_out_times &lt;- matrix(NaN, nrow = popsize, ncol = 15)\n  female_end_out_times &lt;- matrix(NaN, nrow = popsize, ncol = 15)\n  # and another that holds the male they mated with\n  female_mating_partners &lt;- matrix(NaN, nrow =  popsize, ncol = 15)\n  \n  # simulate breeding season in continuous time\n  \n  t &lt;- -20\n  who_dies &lt;- NA # updated when relevant\n  alive &lt;- popsize\n  \n  # we record the OSR at each time point integer\n  next_OSR &lt;- t + 1\n  \n  OSR &lt;- matrix(NaN, nrow = 2*length(next_OSR:5))\n  OSR_row &lt;- 1 # keep track of which row to update\n  \n  event_counter &lt;- 0\n  \nprofvis(\n  while(t &lt; heatwave_time & # this end time point determines when the heatwave kills all the adults\n        alive &gt; 0){ # stop early if everyone dies before the heatwave\n    # gillespie through the events, tracking state changes\n    \n    # count individuals out of the mating pool. Used to calculate next return to mating pool and death times \n    outfemales &lt;- pop[sex &lt; 1 & is.finite(state)]\n    outmales &lt;- pop[sex &gt; 0 & is.finite(state)]\n    # count individuals in the mating pool. We'll also use these numbers to find the next potential mating and death times\n    infemales &lt;- pop[sex &lt; 1 & is.na(state)]\n    inmales &lt;- pop[sex &gt; 0 & is.na(state)]\n    \n    # find next event\n    \n    # emergence\n    next_emergence &lt;- min(pop[emergence_time &gt; t]$emergence_time)\n    \n    # time in\n    #if(nrow(outfemales) + nrow(outmales) &gt; 0){\n    next_time_in &lt;- min(pop$state, na.rm = T) # will this fail if only NaNs?\n    #} else{next_time_in &lt;- Inf} # might not need this line\n    \n    # matings \n    pop_matingrate &lt;- v*nrow(infemales)*nrow(inmales)\n    # compute the time to the next mating... if rate is 0, NaN produced. \n    next_mating &lt;- t + rexp(n = 1, rate = pop_matingrate)\n    \n    # death\n    death_rate &lt;- \n      mu_f_out*nrow(outfemales) +\n      mu_f_in*nrow(infemales) +\n      mu_m_out*nrow(outmales) +\n      mu_m_in*nrow(inmales)\n    \n    next_death &lt;- t + rexp(n = 1, rate = death_rate)\n    \n    # find the next event... if rate is 0, NaN produced.\n    next_t &lt;- pmin(next_emergence,\n                   next_mating,\n                   next_time_in,\n                   next_death,\n                   heatwave_time,\n                   next_OSR,\n                   na.rm = TRUE)\n    \n    t &lt;- next_t # update t\n    \n    # record OSR\n    if(next_t == next_OSR){\n      OSR[OSR_row,] &lt;- nrow(infemales)/nrow(inmales) # this is +20 because we start the timer at -20\n      next_OSR &lt;- next_OSR + 0.5\n      OSR_row &lt;- OSR_row + 1\n    }\n    \n    # update the population by changing the states of individuals\n    \n    # if a male emerges/arrives calculate time till they have produced a spermatophore - this depends on resource abundance\n    if(next_t == next_emergence & !is.na(next_emergence)){\n      # who is it\n      emergence_ID &lt;- pop[emergence_time &gt; t, ID[1]]\n      # state changes depend on sex following emergence      \n      state_value &lt;- NaN # if female start in time-in\n      if (pop[emergence_ID, sex] &gt; 0) { # if male start in time-out\n        state_value &lt;- t + get_male_refractory_period(c_m, t, t0)\n      }\n      # change state\n      set(pop, which(pop$ID == emergence_ID), \"state\", state_value)\n    }\n    \n    # if next event is a return to mating pool\n    if(next_t == next_time_in & !is.na(next_time_in)){\n      # who is it\n      in_ID &lt;- pop[, ID[which.min(state)]]\n      # change state\n      set(pop, which(pop$ID == in_ID), \"state\", NaN) # individuals with state NaN are available as mates\n      # record end time for egg laying period\n      if(pop[in_ID]$sex &lt; 1){\n        NaN_indice &lt;- which(is.nan(female_end_out_times[in_ID, ]))\n        female_end_out_times[in_ID, NaN_indice[1]] &lt;- t\n      }\n    }\n    \n    # if the next event is a mating\n    if(next_t == next_mating & !is.na(next_mating)){\n      # see who does it\n      # everyone searches at the same rate, so within sexes, all individuals in the mating pool have the same probability of mating. \n      # that means we can randomly sample one female and one male from the mating pool\n      who_mates_female &lt;- infemales[sample(.N, 1)]$ID\n      who_mates_male &lt;- inmales[sample(.N, 1)]$ID\n      # change state\n      set(pop, which(pop$ID == who_mates_male), \"state\", t + get_male_refractory_period(c_m, t, t0))\n      set(pop, which(pop$ID == who_mates_female), \"state\", t + get_female_refractory_period(c_f, t, t0, a))\n      # work out how many times the newly mated female had previously mated\n      # specifically, the line below finds the next column indice that has an NaN value\n      #e.g. if a female has mated 3 times, the next NaN will be in column 4\n      NaN_indice &lt;- which(is.nan(female_start_out_times[who_mates_female, ]))\n      #If there are any NaN values, replace the next one in the row with 1\n      if(length(NaN_indice) &gt; 0){ # this is a failsafe, it should never be false\n        female_start_out_times[who_mates_female, NaN_indice[1]] &lt;- t # start egg laying time stamp\n        female_mating_partners[who_mates_female, NaN_indice[1]] &lt;- who_mates_male\n      } else{Mating_limit_exceeded &lt;- \"YES\"} \n    }\n    \n    # if the next event is a death, who dies\n    if(next_t == next_death & !is.na(next_death)){\n      out_f_weight &lt;- (mu_f_out*nrow(outfemales))/death_rate\n      in_f_weight &lt;- (mu_f_in*nrow(infemales))/death_rate\n      out_m_weight &lt;- (mu_m_out*nrow(outmales))/death_rate\n      in_m_weight &lt;- (mu_m_in*nrow(inmales))/death_rate\n      \n      death_class &lt;- \n        sample(c(\"out_f\", \"in_f\", \"out_m\", \"in_m\"),\n               size = 1, \n               prob = c(out_f_weight, in_f_weight, out_m_weight, in_m_weight))\n      \n      if(death_class == \"out_f\"){\n        who_dies &lt;- outfemales[sample(.N, 1)]$ID\n        # end the egg laying period prematurely\n        NaN_indice &lt;- which(is.nan(female_end_out_times[who_dies, ]))\n        female_end_out_times[who_dies, NaN_indice[1]] &lt;- t\n      }\n      if(death_class == \"in_f\"){\n        who_dies &lt;- infemales[sample(.N, 1)]$ID}\n      if(death_class == \"out_m\"){\n        who_dies &lt;- outmales[sample(.N, 1)]$ID}\n      if(death_class == \"in_m\"){\n        who_dies &lt;- inmales[sample(.N, 1)]$ID}\n      # change state\n      set(pop, which(pop$ID == who_dies), \"state\", Inf)\n    }\n    \n    if(next_t == heatwave_time & nrow(outfemales) &gt; 0){\n      # update end times for all females laying eggs\n      female_end_out_times[outfemales$ID, ] &lt;- t(apply(female_end_out_times[outfemales$ID, ], 1, function(row) {\n        nan_index &lt;- match(TRUE, is.nan(row))  # find first NaN\n        if (!is.na(nan_index)) row[nan_index] &lt;- heatwave_time\n        return(row)\n      }))\n    }\n    alive &lt;- nrow(pop[state != Inf | emergence_time &gt; t])\n    event_counter &lt;- event_counter + 1\n    print(t)\n    print(event_counter)\n    \n  }\n)\n  # once the season is complete, compute fecundity and male paternity \n  pop\n  female_start_out_times\n  female_end_out_times\n  female_mating_partners\n  OSR\n  \n}"
  },
  {
    "objectID": "simulation_cuts.html#speed-testing",
    "href": "simulation_cuts.html#speed-testing",
    "title": "Cuts",
    "section": "",
    "text": "Code\nrow &lt;- 1\nsex_limited &lt;- 1\nOSR_recording_interval &lt;- 0.5\n\n\nFew continuous loci inheritance\n\n\nCode\n  if(shared_loci &gt; 0){\n    fel &lt;-  c(\"locus_1a\", \"locus_1b\", \"locus_2a\", \"locus_2b\") # partially resolved sexual antagonism scenario\n    mel &lt;-  c(\"locus_1a\", \"locus_1b\", \"locus_3a\", \"locus_3b\")\n  } else{\n    fel &lt;-  c(\"locus_2a\", \"locus_2b\")\n    mel &lt;-  c(\"locus_3a\", \"locus_3b\")\n  }\n  \n# initialise the population\n# each generation fill the table with allelic values, emergence times and death times\n\n  population_attributes &lt;-\n    data.frame(sex = rbinom(popsize, 1, prob = 0.5), # 0 is female, +1 is male\n               locus_1a = rnorm(popsize, mean = 0, sd = 1), # shared locus parent 1 breeding value (bv)\n               locus_1b = rnorm(popsize, mean = 0, sd = 1), # shared locus parent 2 bv \n               locus_2a = rnorm(popsize, mean = 0, sd = 1), # female limited parent 1 bv\n               locus_2b = rnorm(popsize, mean = 0, sd = 1), # female limited parent 2 bv\n               locus_3a = rnorm(popsize, mean = 0, sd = 1), # male limited parent 1 bv \n               locus_3b = rnorm(popsize, mean = 0, sd = 1), # male limited parent 2 bv\n               state = Inf,\n               p = runif(popsize)) %&gt;% \n    # get breeding values\n    mutate(breeding_value = case_when(sex &gt; 0 & shared_loci &gt; 0 ~ (locus_1a + locus_1b + locus_3a + locus_3b)/4,\n                                      sex &lt; 1 & shared_loci &gt; 0 ~ (locus_1a + locus_1b + locus_2a + locus_2b)/4,\n                                      sex &gt; 0 & shared_loci &lt; 1 ~ (locus_3a + locus_3b)/2,\n                                      sex &lt; 1 & shared_loci &lt; 1 ~ (locus_2a + locus_2b)/2),\n           emergence_time = emergence_sample(breeding_value, p))\n\n\n\n\nCode\n  # initialise the population\n  # each generation fill the table with allelic values, emergence times and death times\n  pop &lt;-\n    data.table(sex = rbinom(popsize, 1, prob = 0.5), # 0 is female, +1 is male\n               locus_1a = rnorm(popsize, mean = 0, sd = 1), # shared locus parent 1 breeding value (bv)\n               locus_1b = rnorm(popsize, mean = 0, sd = 1), # shared locus parent 2 bv \n               locus_2a = rnorm(popsize, mean = 0, sd = 1), # female limited parent 1 bv\n               locus_2b = rnorm(popsize, mean = 0, sd = 1), # female limited parent 2 bv\n               locus_3a = rnorm(popsize, mean = 0, sd = 1), # male limited parent 1 bv \n               locus_3b = rnorm(popsize, mean = 0, sd = 1), # male limited parent 2 bv\n               state = Inf,\n               p = runif(popsize)\n    )[sex &gt; 0, breeding_value := rowMeans(.SD), .SDcols = mel # get male breeding values\n    ][sex &lt; 1, breeding_value := rowMeans(.SD), .SDcols = fel # get female breeding values\n    ][, emergence_time := emergence_sample(breeding_value, p) # everyone starts in 'timeout' bc they haven't arrived\n      ][ ,`:=`(locus_1a = NULL, # remove so sorting is faster during sim \n               locus_1b = NULL,\n               locus_2a = NULL, \n               locus_2b = NULL,\n               locus_3a = NULL, \n               locus_3b = NULL,\n               p = NULL,\n               breeding_value = NULL)]\n  \n  setorder(pop, emergence_time)[, ID := 1:popsize] # order by emergence time to make downstream operations faster, then set ID for each individual\n  \n  #total_time_out = rep(0, popsize))] # only relevant for females]\n  # for state - NaN: in mating pool, real number: time out with number indicating when they'll return, Inf: dead or yet to emerge\n  \n  # create empty array to hold female mating times \n  #adult_females &lt;- pop[pop$sex &lt; 1, \"ID\"] # females that survive density regulation\n  # we assume that females can't mate more than 20 times across the season\n  female_start_out_times &lt;- matrix(NaN, nrow = popsize, ncol = 15)\n  female_end_out_times &lt;- matrix(NaN, nrow = popsize, ncol = 15)\n  # and another that holds the male they mated with\n  female_mating_partners &lt;- matrix(NaN, nrow =  popsize, ncol = 15)\n  \n  # simulate breeding season in continuous time\n  \n  t &lt;- -20\n  who_dies &lt;- NA # updated when relevant\n  alive &lt;- popsize\n  \n  # we record the OSR at each time point integer\n  next_OSR &lt;- t + 1\n  \n  OSR &lt;- matrix(NaN, nrow = 2*length(next_OSR:5))\n  OSR_row &lt;- 1 # keep track of which row to update\n  \n  event_counter &lt;- 0\n  \nprofvis(\n  while(t &lt; heatwave_time & # this end time point determines when the heatwave kills all the adults\n        alive &gt; 0){ # stop early if everyone dies before the heatwave\n    # gillespie through the events, tracking state changes\n    \n    # count individuals out of the mating pool. Used to calculate next return to mating pool and death times \n    outfemales &lt;- pop[sex &lt; 1 & is.finite(state)]\n    outmales &lt;- pop[sex &gt; 0 & is.finite(state)]\n    # count individuals in the mating pool. We'll also use these numbers to find the next potential mating and death times\n    infemales &lt;- pop[sex &lt; 1 & is.na(state)]\n    inmales &lt;- pop[sex &gt; 0 & is.na(state)]\n    \n    # find next event\n    \n    # emergence\n    next_emergence &lt;- min(pop[emergence_time &gt; t]$emergence_time)\n    \n    # time in\n    #if(nrow(outfemales) + nrow(outmales) &gt; 0){\n    next_time_in &lt;- min(pop$state, na.rm = T) # will this fail if only NaNs?\n    #} else{next_time_in &lt;- Inf} # might not need this line\n    \n    # matings \n    pop_matingrate &lt;- v*nrow(infemales)*nrow(inmales)\n    # compute the time to the next mating... if rate is 0, NaN produced. \n    next_mating &lt;- t + rexp(n = 1, rate = pop_matingrate)\n    \n    # death\n    death_rate &lt;- \n      mu_f_out*nrow(outfemales) +\n      mu_f_in*nrow(infemales) +\n      mu_m_out*nrow(outmales) +\n      mu_m_in*nrow(inmales)\n    \n    next_death &lt;- t + rexp(n = 1, rate = death_rate)\n    \n    # find the next event... if rate is 0, NaN produced.\n    next_t &lt;- pmin(next_emergence,\n                   next_mating,\n                   next_time_in,\n                   next_death,\n                   heatwave_time,\n                   next_OSR,\n                   na.rm = TRUE)\n    \n    t &lt;- next_t # update t\n    \n    # record OSR\n    if(next_t == next_OSR){\n      OSR[OSR_row,] &lt;- nrow(infemales)/nrow(inmales) # this is +20 because we start the timer at -20\n      next_OSR &lt;- next_OSR + 0.5\n      OSR_row &lt;- OSR_row + 1\n    }\n    \n    # update the population by changing the states of individuals\n    \n    # if a male emerges/arrives calculate time till they have produced a spermatophore - this depends on resource abundance\n    if(next_t == next_emergence & !is.na(next_emergence)){\n      # who is it\n      emergence_ID &lt;- pop[emergence_time &gt; t, ID[1]]\n      # state changes depend on sex following emergence      \n      state_value &lt;- NaN # if female start in time-in\n      if (pop[emergence_ID, sex] &gt; 0) { # if male start in time-out\n        state_value &lt;- t + get_male_refractory_period(c_m, t, t0)\n      }\n      # change state\n      set(pop, which(pop$ID == emergence_ID), \"state\", state_value)\n    }\n    \n    # if next event is a return to mating pool\n    if(next_t == next_time_in & !is.na(next_time_in)){\n      # who is it\n      in_ID &lt;- pop[, ID[which.min(state)]]\n      # change state\n      set(pop, which(pop$ID == in_ID), \"state\", NaN) # individuals with state NaN are available as mates\n      # record end time for egg laying period\n      if(pop[in_ID]$sex &lt; 1){\n        NaN_indice &lt;- which(is.nan(female_end_out_times[in_ID, ]))\n        female_end_out_times[in_ID, NaN_indice[1]] &lt;- t\n      }\n    }\n    \n    # if the next event is a mating\n    if(next_t == next_mating & !is.na(next_mating)){\n      # see who does it\n      # everyone searches at the same rate, so within sexes, all individuals in the mating pool have the same probability of mating. \n      # that means we can randomly sample one female and one male from the mating pool\n      who_mates_female &lt;- infemales[sample(.N, 1)]$ID\n      who_mates_male &lt;- inmales[sample(.N, 1)]$ID\n      # change state\n      set(pop, which(pop$ID == who_mates_male), \"state\", t + get_male_refractory_period(c_m, t, t0))\n      set(pop, which(pop$ID == who_mates_female), \"state\", t + get_female_refractory_period(c_f, t, t0, a))\n      # work out how many times the newly mated female had previously mated\n      # specifically, the line below finds the next column indice that has an NaN value\n      #e.g. if a female has mated 3 times, the next NaN will be in column 4\n      NaN_indice &lt;- which(is.nan(female_start_out_times[who_mates_female, ]))\n      #If there are any NaN values, replace the next one in the row with 1\n      if(length(NaN_indice) &gt; 0){ # this is a failsafe, it should never be false\n        female_start_out_times[who_mates_female, NaN_indice[1]] &lt;- t # start egg laying time stamp\n        female_mating_partners[who_mates_female, NaN_indice[1]] &lt;- who_mates_male\n      } else{Mating_limit_exceeded &lt;- \"YES\"} \n    }\n    \n    # if the next event is a death, who dies\n    if(next_t == next_death & !is.na(next_death)){\n      out_f_weight &lt;- (mu_f_out*nrow(outfemales))/death_rate\n      in_f_weight &lt;- (mu_f_in*nrow(infemales))/death_rate\n      out_m_weight &lt;- (mu_m_out*nrow(outmales))/death_rate\n      in_m_weight &lt;- (mu_m_in*nrow(inmales))/death_rate\n      \n      death_class &lt;- \n        sample(c(\"out_f\", \"in_f\", \"out_m\", \"in_m\"),\n               size = 1, \n               prob = c(out_f_weight, in_f_weight, out_m_weight, in_m_weight))\n      \n      if(death_class == \"out_f\"){\n        who_dies &lt;- outfemales[sample(.N, 1)]$ID\n        # end the egg laying period prematurely\n        NaN_indice &lt;- which(is.nan(female_end_out_times[who_dies, ]))\n        female_end_out_times[who_dies, NaN_indice[1]] &lt;- t\n      }\n      if(death_class == \"in_f\"){\n        who_dies &lt;- infemales[sample(.N, 1)]$ID}\n      if(death_class == \"out_m\"){\n        who_dies &lt;- outmales[sample(.N, 1)]$ID}\n      if(death_class == \"in_m\"){\n        who_dies &lt;- inmales[sample(.N, 1)]$ID}\n      # change state\n      set(pop, which(pop$ID == who_dies), \"state\", Inf)\n    }\n    \n    if(next_t == heatwave_time & nrow(outfemales) &gt; 0){\n      # update end times for all females laying eggs\n      female_end_out_times[outfemales$ID, ] &lt;- t(apply(female_end_out_times[outfemales$ID, ], 1, function(row) {\n        nan_index &lt;- match(TRUE, is.nan(row))  # find first NaN\n        if (!is.na(nan_index)) row[nan_index] &lt;- heatwave_time\n        return(row)\n      }))\n    }\n    alive &lt;- nrow(pop[state != Inf | emergence_time &gt; t])\n    event_counter &lt;- event_counter + 1\n    print(t)\n    print(event_counter)\n    \n  }\n)\n  # once the season is complete, compute fecundity and male paternity \n  pop\n  female_start_out_times\n  female_end_out_times\n  female_mating_partners\n  OSR\n  \n}"
  },
  {
    "objectID": "simulation_cuts.html#test-plotting",
    "href": "simulation_cuts.html#test-plotting",
    "title": "Cuts",
    "section": "Test plotting",
    "text": "Test plotting\nThe simulation produces nonsensical results. Let’s investigate whether this is the result of a fitness calculation error, an inheritance error or some third unexpected cause.\nFirst, let’s have a look at female fitness. The plots below show that it behaves as it should. Time out increases with earlier emergence (to a point) and this translates to offspring production.\n\n\nCode\nf_fitness &lt;- \n  tibble(time_out = rowSums(female_out_times, na.rm = T)) %&gt;%\n  bind_cols(pop) %&gt;% \n  filter(sex == 0) %&gt;%\n  left_join(tibble(ID = mothers) %&gt;% count(ID)) %&gt;% \n  rename(offspring = n) %&gt;% \n  mutate(offspring = if_else(is.na(offspring), 0, offspring)) %&gt;% \n  left_join(genetics, by = \"ID\")\n\na &lt;-\n  f_fitness %&gt;% \n  ggplot(aes(x = emergence_time, y = time_out)) + \n  geom_point() +\n  geom_smooth(method = \"gam\")\n\nb &lt;-\n  f_fitness %&gt;% \n  ggplot(aes(x = time_out, y = offspring)) +\n  geom_point() +\n  geom_smooth(method = \"gam\")\n\nc &lt;-\n  f_fitness %&gt;% \n  ggplot(aes(x = emergence_time, y = offspring)) +\n  geom_point() +\n  geom_smooth(method = \"gam\")\n\nd &lt;-\n  f_fitness %&gt;% \n  ggplot(aes(x = f_limited_bv, y = offspring)) + \n  geom_point() +\n  geom_smooth(method = \"gam\")\n\n(a+b) / (c+d)\n\n\nWhat about male fitness?\nThis also behaves as expected. Males that emerge earlier have higher mating success and as a result, sire more offspring.\n\n\nCode\nm_fitness &lt;-\n  female_mating_partners %&gt;% \n  as_tibble() %&gt;% \n  pivot_longer(cols = everything(), names_to = \"mate_number\", values_to = \"ID\") %&gt;% \n  mutate(mate_number = as.numeric(str_remove(mate_number, \"V\"))) %&gt;% \n  filter(!is.na(ID)) %&gt;% \n  arrange(mate_number) %&gt;% \n  count(ID) %&gt;% \n  arrange(ID) %&gt;% \n  rename(mating_success = n) %&gt;% \n  right_join(pop) %&gt;%\n  filter(sex == 1) %&gt;% \n  mutate(mating_success = if_else(is.na(mating_success), \n                                  0, \n                                  mating_success)) %&gt;%\n  left_join(tibble(ID = as.numeric(fathers)) %&gt;% \n              count(ID) %&gt;% \n              rename(offspring = n)) %&gt;% \n  mutate(offspring = if_else(is.na(offspring), \n                                  0, \n                                  offspring)) %&gt;% \n  left_join(genetics)\n\ne &lt;-\n  m_fitness %&gt;% \n  ggplot(aes(x = m_limited_bv, y = mating_success)) + \n  geom_jitter() +\n  geom_smooth(method = \"gam\")\n\nf &lt;-\n  m_fitness %&gt;% \n  ggplot(aes(x = mating_success, y = offspring)) +\n  geom_jitter() +\n  geom_smooth()\n\ng &lt;-\n  m_fitness %&gt;% \n  ggplot(aes(x = emergence_time, y = offspring)) +\n  geom_jitter() +\n  geom_smooth(method = \"gam\")\n\nh &lt;-\n  m_fitness %&gt;% \n  ggplot(aes(x = m_limited_bv, y = offspring)) + \n  geom_jitter() +\n  geom_smooth(method = \"gam\")\n\n(e+f) / (g+h)"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "Project meeting notes",
    "section": "",
    "text": "Males often arrive early, and this has fitness benefits - early monopolisation of females, the chance to mate throughout the mating season etc.\nFemales might not want to arrive so early because they don’t have to mate so much, mating a lot might be bad, or they want to time arrival/emergence with resource availability for their offspring.\nBut if males keep arriving earlier, selection begins to favour earlier arrival in females as well, because the risk of going unmated grows larger.\nThis can start a runaway process of earlier and earlier emergence for both sexes. In typical interlocus conflict fashion, males harm females as a biproduct of male-male competition for fertilisations. Absolute female fitness decreases because they evolve to emerge/arrive further from the resource peak.\nThe runaway process is eventually stopped when female arrival gets too far away from the resource peak.\nThe result is sexual conflict load, where females are potentially not optimally adapted on either front (finding mates or enjoying lots of resources).\n\n\n\n\n\nThe current model only considers females that can be inseminated once. What happens if there is polyandry?\nMy first thoughts are: females will deplete male sperm stores more rapidly, which might increase the rate of matelessness and select females that arrive earlier. This pushes emergence time further still from the resource. However, now there is sperm competition. If there is last male precedence, then perhaps selection on males to arrive earlier is abated. This is potentially good for the population because the arms race does not drive arrival time as far away from the resource as previously found."
  },
  {
    "objectID": "notes.html#brief-summary-of-the-2023-paper",
    "href": "notes.html#brief-summary-of-the-2023-paper",
    "title": "Project meeting notes",
    "section": "",
    "text": "Males often arrive early, and this has fitness benefits - early monopolisation of females, the chance to mate throughout the mating season etc.\nFemales might not want to arrive so early because they don’t have to mate so much, mating a lot might be bad, or they want to time arrival/emergence with resource availability for their offspring.\nBut if males keep arriving earlier, selection begins to favour earlier arrival in females as well, because the risk of going unmated grows larger.\nThis can start a runaway process of earlier and earlier emergence for both sexes. In typical interlocus conflict fashion, males harm females as a biproduct of male-male competition for fertilisations. Absolute female fitness decreases because they evolve to emerge/arrive further from the resource peak.\nThe runaway process is eventually stopped when female arrival gets too far away from the resource peak.\nThe result is sexual conflict load, where females are potentially not optimally adapted on either front (finding mates or enjoying lots of resources).\n\n\n\n\n\nThe current model only considers females that can be inseminated once. What happens if there is polyandry?\nMy first thoughts are: females will deplete male sperm stores more rapidly, which might increase the rate of matelessness and select females that arrive earlier. This pushes emergence time further still from the resource. However, now there is sperm competition. If there is last male precedence, then perhaps selection on males to arrive earlier is abated. This is potentially good for the population because the arms race does not drive arrival time as far away from the resource as previously found."
  },
  {
    "objectID": "notes.html#section",
    "href": "notes.html#section",
    "title": "Project meeting notes",
    "section": "17/10/23",
    "text": "17/10/23\n\nThe West Australian Bush cricket\nLeigh will send through some info on the lifecycle / other relevant stuff like sperm precedence etc.\nThey are sperm mixers, with a little bit of second male precedence (I think)\nResources become available as pollen during the brief flowering season. Heat waves at the end of this period result in very high mortality for adults, but eggs can survive in diapause.\nFemales are polyandrous, but the extent to which they are depends on resource availability.\nIf resources are abundant, then females become less interested in mating and sexual selection is stronger in males than females.\nIf resources are scarce, females depend upon the male spermatophore for nutrition. Males can only produce one spermatophore every 5-10 days, so they quickly become a limiting resource. Females therefore compete vigorously for males and sexual selection potentially becomes female-biased.\nThis is relevant for protandry because it determines reproductive success in both sexes, but in a way that depends upon resource availability. It is therefore a really nice system to test the models predictions with manipulative experiments.\nProtandry can be viewed in terms of the length of development. This may be plastic and reflective of the resource availability conditions.\ni.e. if you make resources scarce, then females should plastically shorten their development, whereas if resources are abundant, females should match development with male availability and resource availability.\nI need more info on the above to make the prediction clear."
  },
  {
    "objectID": "simulation.html",
    "href": "simulation.html",
    "title": "Simulation",
    "section": "",
    "text": "Code\nlibrary(tidyverse)\nlibrary(geomtextpath)\nlibrary(MoMAColors)\nlibrary(PNWColors)\nlibrary(bench)\nlibrary(patchwork)\nlibrary(stickylabeller)\n\nsensible_sample &lt;- function(x, ...){x[sample(length(x), ...)]}"
  },
  {
    "objectID": "simulation.html#load-packages",
    "href": "simulation.html#load-packages",
    "title": "Simulation",
    "section": "",
    "text": "Code\nlibrary(tidyverse)\nlibrary(geomtextpath)\nlibrary(MoMAColors)\nlibrary(PNWColors)\nlibrary(bench)\nlibrary(patchwork)\nlibrary(stickylabeller)\n\nsensible_sample &lt;- function(x, ...){x[sample(length(x), ...)]}"
  },
  {
    "objectID": "simulation.html#build-helpful-functions",
    "href": "simulation.html#build-helpful-functions",
    "title": "Simulation",
    "section": "Build helpful functions",
    "text": "Build helpful functions\n\nEmergence\n\n\nCode\nemergence_sample &lt;- function(emergence_breeding_value, p){\n# T is the emergence breeding value  \n# we take advantage of the fact that the cumulative distribution of the emergence time is exp(t)/(exp(t)+exp(T)), \n# hence the t that corresponds to a uniformly distributed p is ln(exp(T) p/(1-p)) = ln(exp(T))+ln(p/(1-p)) = T+ln(p/(1-p))\n\n#p &lt;- runif(length(emergence_breeding_value))\nemergence_breeding_value+log(p/(1-p))\n}\n\n\n\n\nResource abundance\nHow resources increase with time is described by the logistic growth function\n\\[R(t) = \\frac{1}{1 + e^{-k(t - t_0)}}\\] where \\(t_0\\) is the \\(t\\) value of the functions midpoint. The function saturates at 1, which indicates the point where female fecundity is no longer limited by resource abundance. Here’s what it looks like for different values of \\(t_0\\), with \\(k\\) = 1.\n\n\nCode\nexpand_grid(t = seq(from = -20, to = 20, by = 0.1),\n       t0 = seq(from = -5, to = 5, by = 1)) %&gt;% \n  mutate(resources = 1/(1 + exp(-1*(t - t0))),\n         resources = case_when(t &gt; 10 ~ NaN,\n                               .default = resources)) %&gt;% \n  ggplot(aes(x = t, y = resources)) +\n  geom_vline(xintercept = 10, linetype = 2, linewidth = 1) +\n  geom_line(aes(colour = t0, group = t0), linewidth = 1.5) +\n  scale_color_moma_c(\"Panton\") +\n  scale_x_continuous(limits = c(-10, 11), expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0, 0)) +\n  labs(x = \"Time, t\",\n       y = \"Resource abundance\",\n       colour = \"t0\") +\n  theme_bw() +\n  theme(text = element_text(size = 16))\n\n\n\n\n\n\n\n\n\nBuild the helper function\n\\(R(t)\\) describes how resources flow into the system as time passes. Under the simplifying assumptions that spermatophore size is fixed across the population and that resource acquisition is independent of conspecific desnity and behaviour, the male refractory period is \\(x-T\\), where \\(T\\) is the time during the season when a male starts building a spermatophore and \\(x\\) is the time-point at which he has gathered sufficient resources to produce a complete spermatophore. We calculate spermatophore production between two points in the season as \\[\nA = \\int_{T}^{x} \\frac{1}{c_\\mathrm{m} + e^{-k(t - t_0)}} \\,dt\n\\] where \\(k\\) determines the rate at which resources enter the system and \\(c_\\mathrm{m}\\) controls how efficiently males convert these resources into spermatophore. When \\(c_\\mathrm{m}\\) is small, spermatophore production is efficient/cheap. We set the necessary amount of resources required to complete a spermatophore to \\(A = 1\\) and for a given value of \\(T\\) find males return to the mating pool at time\n\\[\nx = \\frac{kt_0 + \\mathrm{Log}[\\frac{-1+e^{c_\\mathrm{m}k} + c_\\mathrm{m}e^{c_\\mathrm{m}k + k (T-t_0)}}{c_\\mathrm{m}}]}{k}\n\\]\n\n\n\n\n\n\nAn alternative\n\n\n\n\\(R(t)\\) describes how resources flow into the system as time passes. Let the speed at which males convert available resources into spermatophore be governed by the constant \\(c\\), such that the male refractory period is \\(r_\\mathrm{m}(R) = cT_Be^{-kR}+r_0\\), where \\(T_B\\) is the length of the breeding season (this is L in Hanna’s model), \\(r_0\\) is the time required to build a spermatophore at the resource peak, and \\(k\\) determines the rate at which the refractory decreases with an increase in resources.\n\n\nResource availability has the opposite effect on the female refractory period. We assume that females use the resources available to them immediately after mating to produce eggs, which they then spend time out of the mating pool ovipositing. Females lay eggs at a population-wide constant rate; the time spent out of the mating pool is therefore determined by the number of eggs they were able to produce immediately after mating. Longer refractory periods result from having a greater number of eggs to lay. Females also acquire resources from the spermatophore they receive during mating, which provides an additive ‘bump’ to the resources they have at their disposal. The efficiency at which females convert resources into eggs is controlled by the constant \\(c_\\mathrm{f}\\), such that the female refractory is \\(r_\\mathrm{f}=c_\\mathrm{f}(R(t) + s)\\), where \\(s\\) is a population-wide constant that controls the nutritional content of the spermatophore. Any values of \\(R(t) + s\\) that exceed 1 are reset to 1; the value where female fecundity is no longer limited by resources.\nSet \\(c_\\mathrm{f}\\) = 3, \\(c_\\mathrm{m}\\) = 0.5, \\(s\\) = 0, \\(k\\) = 0.5, \\(t_0\\) = 0 and plot\n\n\nCode\npanel_1 &lt;- \n  expand_grid(t = seq(from = -20, to = 20, by = 0.1),\n       t0 = 0,\n       k = 0.5) %&gt;% \n  mutate(resources = 1/(1 + exp(-k*(t - t0))),\n         resources = case_when(t &gt; 15 ~ NaN,\n                               .default = resources),\n         end_y = 1/(1 + exp(-k*(-1 - t0)))) %&gt;% \n  ggplot(aes(x = t, y = resources)) +\n  geom_segment(x = 0, xend=0, \n               y = -Inf, yend=0.5, \n               colour = \"black\", linetype = 2, linewidth = 0.7) +\n  geom_vline(xintercept = 15, linetype = 2, linewidth = 0.7) +\n  geom_line(linewidth = 1) +\n  scale_x_continuous(limits = c(-10, 15.5), expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0.005, 0.005)) +\n  labs(x = \"Time, t\",\n       y = \"Resource abundance\") +\n  theme_bw() +\n  theme(text = element_text(size = 16),\n        legend.position = \"none\")\n\npanel_2 &lt;-\nexpand_grid(t = seq(from = -20, to = 20, by = 0.1),\n       t0 = seq(from = -10, to = 15, by = 1),\n       cm = 0.5,\n       fm = 3, \n       k = 0.5) %&gt;% \n  mutate(male_timeout = ((k*t0 + log((-1 + exp(cm*k) + cm*exp(cm*k+k*(t-t0)))/(cm)))/k)-t,\n         female_timeout = (fm/(1 + exp(-k*(t - t0)))),\n         male_timeout = case_when(t &gt; 15 ~ NaN,\n                               .default = male_timeout),\n         female_timeout = case_when(t &gt; 15 ~ NaN,\n                               .default = female_timeout)) %&gt;% \n  filter(t0 == 0) %&gt;% \n  ggplot(aes(x = t)) +\n  geom_vline(xintercept = 15, linetype = 2, linewidth = 0.7) +\n  geom_vline(xintercept = 0, linetype = 2, linewidth = 0.7) +\n  geom_textline(aes(y = male_timeout, label = \"Males\"), size = 6, hjust = 0.12) +\n  geom_textline(aes(y = female_timeout, label = \"Females\"), size = 6, hjust = 0.12) +\n  scale_x_continuous(limits = c(-10, 15.5), expand = c(0, 0)) +\n  scale_y_continuous(expand = c(0.005, 0.005)) +\n    labs(x = \"Time, t\",\n       y = \"Time out (mean expectation)\") +\n  scale_y_continuous(breaks = c(0, 2, 4, 6, 8, 10, 12,\n                                14, 16, 18, 20)) +\n  theme_bw() +\n  theme(text = element_text(size = 16))\n\npanel_1 / panel_2 + plot_layout(axes = \"collect\")\n\n\n\n\n\n\n\n\n\nBuild the refractory functions for the simulation\n\n\nCode\n# this doesn't find refractory period, but rather the time the male re-enters the mating pool\nget_male_time_in &lt;- function(c_m, t, t0, k){\n  (k*t0 + log((-1 + exp(c_m*k) + c_m*exp(c_m*k+k*(t-t0)))/(c_m)))/k\n}\n\n# females acquire resources via flowers and spermatophores \n\nget_female_resource_quantity &lt;- function(t, t0, k, s){\n  R_t &lt;- (1/(1 + exp(-k*(t - t0)))) + s\n  \n  if(R_t &gt; 1){R_t &lt;- 1}\n  \n  R_t\n}\n\n\n\n\nFitness\nThe quantity maximised by selection on both sexes is lifetime reproductive success. For females, this is equivalent to the total time they spend in time-out, ovipositing eggs. We treat eggs like tickets in a lottery, and draw mothers for adults in the next generation, weighted by the number of ‘tickets’ each female has. The relevant lottery is density-dependent viability selection, which we assume to occur prior to the reproductive life-stage, with each egg having equal probability of making it.\nFor males, reproductive success depends on mating success, the fecundity of a male’s mates and the intensity of sperm competition the male faces within each female he inseminates. We model sperm competition under complete sperm-mixing, where a single mating is sufficient to fill the spermatheca. Specifically, when a female mates with a second male, she dumps half of the total sperm she has received randomly (as she has received enough to fill her spermatheca twice-over), such that her spermatheca now contains equal parts of male one and male two’s ejaculate. If she mates a third time, she again dumps half the sperm, such that male three contributes half the present sperm, and male one and male two’s representation is reduced to a quarter. A female’s recent mates therefore have the highest chance of siring her offspring. To put this in perspective, a male’s probability of fathering offspring from a given reproductive bout reduces to ~0.01 if the female has subsequently mated six more times. For completeness, we consider cases where females have mated up to 15 times, though this rarely if ever occurs in simulations.\n\n\nCode\n# get total length of time each mating caused a female to leave mating pool == LRS \n\n# we assume complete sperm-mixing and that one insemination event fills the spermatheca\n\n# columns are how polyandrous a female has been\n# rows hold the mating partner's paternity prob, which depends on how many times the female has subsequently mated \n\nsperm_mixing_weights &lt;-\n  data.frame(Mating1 = c(1, rep(0, 14)),\n         Mating2 = c(0.5, 0.5, rep(0, 13)),\n         Mating3 = c(0.5^2, 0.5^2, 0.5, rep(0, 12)),\n         Mating4 = c(0.5^3, 0.5^3, 0.5^2, 0.5, rep(0, 11)),\n         Mating5 = c(0.5^4, 0.5^4, 0.5^3, 0.5^2, 0.5, rep(0, 10)),\n         Mating6 = c(0.5^5, 0.5^5, 0.5^4, 0.5^3, 0.5^2, 0.5, rep(0, 9)),\n         Mating7 = c(0.5^6, 0.5^6, 0.5^5, 0.5^4, 0.5^3, 0.5^2, 0.5, rep(0, 8)),\n         Mating8 = c(0.5^7, 0.5^7, 0.5^6, 0.5^5, 0.5^4, 0.5^3, 0.5^2, 0.5, rep(0, 7)),\n         Mating9 = c(0.5^8, 0.5^8, 0.5^7, 0.5^6, 0.5^5, 0.5^4, 0.5^3, 0.5^2, 0.5,\n                     rep(0, 6)),\n         Mating10 = c(0.5^9, 0.5^9, 0.5^8, 0.5^7, 0.5^6, 0.5^5, 0.5^4, 0.5^3, 0.5^2,\n                      0.5, rep(0, 5)),\n         Mating11 = c(0.5^10, 0.5^10, 0.5^9, 0.5^8, 0.5^7, 0.5^6, 0.5^5, 0.5^4, 0.5^3,\n                      0.5^2, 0.5, rep(0, 4)),\n         Mating12 = c(0.5^11, 0.5^11, 0.5^10, 0.5^9, 0.5^8, 0.5^7, 0.5^6, 0.5^5,\n                      0.5^4, 0.5^3, 0.5^2, 0.5, rep(0, 3)),\n         Mating13 = c(0.5^12, 0.5^12, 0.5^11, 0.5^10, 0.5^9, 0.5^8, 0.5^7, 0.5^6,\n                      0.5^5, 0.5^4, 0.5^3, 0.5^2, 0.5, rep(0, 2)),\n         Mating14 = c(0.5^13, 0.5^13, 0.5^12, 0.5^11, 0.5^10, 0.5^9, 0.5^8, 0.5^7,\n                      0.5^6, 0.5^5, 0.5^4, 0.5^3, 0.5^2, 0.5, rep(0, 1)),\n         Mating15 = c(0.5^14, 0.5^14, 0.5^13, 0.5^12, 0.5^11, 0.5^10, 0.5^9, 0.5^8,\n                      0.5^7, 0.5^6, 0.5^5, 0.5^4, 0.5^3, 0.5^2, 0.5))\n\n# mother function\n\nmother_finder_function &lt;- \n  function(fecundity_matrix, # holds times for reproductive bouts\n           carrying_capacity){ # holds times when females end each egg-laying bout\n    \n    # find mothers\n    # get likelihoods for mothering success\n    probs &lt;- rowSums(fecundity_matrix, na.rm = T)/sum(fecundity_matrix, na.rm = T)\n    # find mothers of the next generation\n    mothers &lt;- sensible_sample(x = 1:carrying_capacity, size = carrying_capacity, prob = probs, replace = T) \n    \n    mothers\n    \n    # sanity check - are all mothers female? \n    \n    #if(setdiff(mothers, pop %&gt;% filter(sex == 0) %&gt;% pull(ID))&gt;0){ # should return 0\n    #  print(\"some mothers are male!\")\n    #} \n  }\n\n# father function\n\nfather_finder_function &lt;- \n  function(mothers, # from mother finder function\n           fecundity_matrix,\n           mates,\n           sperm_comp_array){ # how does sperm comp work\n    \n    fathers &lt;- rep(\"NaN\", length(mothers))\n    offspring &lt;- 1 # pick a father for the first adult in the next gen; iterate through all individuals\n    # empty vector to be filled; females assumed to have mated a max of 15 times\n    fecundity_weights &lt;- c(rep(0, nrow(sperm_comp_array)))\n    \n    while(offspring &lt;= length(mothers)){\n      # no. of mates\n      number_mates &lt;- sum(!is.na(mates[mothers[offspring], ]))\n      # who are the mates\n      mate_IDs &lt;- mates[mothers[offspring], 1:number_mates]\n      \n      if(number_mates &gt; 1){\n        fecundity_weights[1:number_mates] &lt;- \n          fecundity_matrix[mothers[offspring], 1:number_mates] / \n          sum(fecundity_matrix[mothers[offspring], 1:number_mates])\n        \n        paternity_weights &lt;-\n          rowSums(data.frame(mapply(`*`,sperm_comp_array,fecundity_weights)))\n        \n        father &lt;- sensible_sample(mate_IDs, size = 1, prob = paternity_weights[1:number_mates])\n      }else{father &lt;- mate_IDs}\n      \n      fathers[offspring] &lt;- father\n      \n      offspring &lt;- offspring + 1\n      \n    }\n    \n    fathers\n  }"
  },
  {
    "objectID": "simulation.html#define-parameter-space",
    "href": "simulation.html#define-parameter-space",
    "title": "Simulation",
    "section": "Define parameter space",
    "text": "Define parameter space\n\n\nCode\nparameter_space &lt;- \n  expand_grid(popsize = 500,\n              mu_f_in = 0.1,\n              mu_f_out = 0.1,\n              mu_m_in = 0.1,\n              mu_m_out = 0.1,\n              v = 8/(popsize / 2), # rate searching sex finds other sex\n              c_m = 0.5, # min time to regen spermatophore\n              c_f = seq(from = 0.5, to = 10, by = 0.5),\n              s = c(0, 0.1, 0.25), # spermatophore boost\n              t0 = 0, # 50% resources at time 0\n              k = 0.5,\n              genome_wide_mutation = 0.2, # sd for normal with mu = 0\n              heatwave_time = seq(from = 0, to = 12, by = 0.5), # when are all the adults killed each year\n              gens = 2000)"
  },
  {
    "objectID": "simulation.html#the-main-simulation-function",
    "href": "simulation.html#the-main-simulation-function",
    "title": "Simulation",
    "section": "The main simulation function",
    "text": "The main simulation function\n\n\nCode\nmain_sim &lt;- function(row, # which row of the parameter space\n                     input, # the parameter space\n                     sex_limited, # -1 = no, +1 = yes\n                     OSR_recording_interval, # time points to record OSR\n                     sperm_competition_weightings\n){\n  #print(paste(\"doing row\", row))\n  \n  # define constants\n  popsize &lt;- input$popsize[row] \n  mu_f_in &lt;- input$mu_f_in[row] # female death rate in mating pool\n  mu_f_out &lt;- input$mu_f_out[row] # female death rate out of the mating pool\n  mu_m_in &lt;- input$mu_m_in[row] # male death rate in the mating pool\n  mu_m_out &lt;- input$mu_m_out[row] # mating death rate out of the mating pool\n  v &lt;- input$v[row] # velocity of male mate searching - all males have same value\n  c_m &lt;- input$c_m[row]\n  c_f &lt;- input$c_f[row]\n  s &lt;- input$s[row]\n  t0 &lt;- input$t0[row]\n  k &lt;- input$k[row]\n  genome_wide_mutation &lt;- input$genome_wide_mutation[row]\n  heatwave_time &lt;- input$heatwave_time[row]\n  gens &lt;- input$gens[row]\n  \n  sperm_comp_weights &lt;- sperm_competition_weightings\n  \n  # initialise the population\n  # each generation fill the table with breeding values, emergence times and death times\n  \n  if(sex_limited &lt; 1){ # we only need to track one trait\n    \n    population_attributes &lt;-\n      data.frame(sex = rbinom(popsize, 1, prob = 0.5), # 0 is female, +1 is male\n                 breeding_value = rnorm(popsize, mean = 0, sd = 1),\n                 state = Inf,\n                 p = runif(popsize)) %&gt;% \n      mutate(emergence_time = emergence_sample(breeding_value, p)) %&gt;% # get emergence time\n      arrange(emergence_time) %&gt;% # order by emergence time to make downstream operations faster\n      mutate(ID = 1:popsize) # set ID for each individual\n    \n    pop &lt;-\n      population_attributes %&gt;% \n      select(-c(p, breeding_value)) # remove un-needed columns\n    \n    genetics &lt;- \n      population_attributes %&gt;% \n      select(ID, breeding_value)\n    \n  } else{ # we need to track two traits\n    population_attributes &lt;-\n      data.frame(sex = rbinom(popsize, 1, prob = 0.5), # 0 = female, +1 = male\n                 f_limited_bv = rnorm(popsize, mean = 0, sd = 1), \n                 m_limited_bv = rnorm(popsize, mean = 0, sd = 1),  \n                 state = Inf,\n                 p = runif(popsize)) %&gt;% \n      # get emergence time\n      mutate(emergence_time = case_when(sex &gt; 0 ~ emergence_sample(m_limited_bv, p),\n                                        sex &lt; 1 ~ emergence_sample(f_limited_bv, p))) %&gt;% \n      arrange(emergence_time) %&gt;% # order by emergence time to make downstream operations faster\n      mutate(ID = 1:popsize) # set ID for each individual\n    \n    pop &lt;-\n      population_attributes %&gt;% \n      select(-c(contains(\"bv\"), p)) # remove un-needed columns\n    \n    genetics &lt;- \n      population_attributes %&gt;% \n      select(ID, f_limited_bv, m_limited_bv)\n  }\n  \n  # for state: \n  # NaN: in mating pool, \n  # real number: time out with number indicating when they'll return \n  # Inf: dead or yet to emerge\n  \n  # setup array to record results every generation\n  mean_trait_value &lt;- matrix(NaN, ncol = 4, nrow = length(0:gens))\n  \n  OSR_list &lt;- list(rep(NaN, length(0:gens)))\n  \n  # simulate evolution over many generations - within each generation, fitness is accrued during the breeding season, which we simulate with a gillespie-like process of events \n  G &lt;- 0  \n  matings &lt;- 1 # placeholder to get things started - sim will quit if no females mate\n  \n  while(G &lt;= gens & matings &gt; 0){  \n    \n    #print(paste(\"running generation\", G))\n    \n    # record mean breeding value in the population before selection\n    # genetic variance in trait values\n    if(sex_limited &gt; 0){\n      mean_trait_value[G+1,1] &lt;- mean(genetics$f_limited_bv) # f\n      mean_trait_value[G+1,2] &lt;- sd(genetics$f_limited_bv) # f\n      mean_trait_value[G+1,3] &lt;- mean(genetics$m_limited_bv) # m\n      mean_trait_value[G+1,4] &lt;- sd(genetics$m_limited_bv) # m\n    } else{\n      mean_trait_value[G+1,1] &lt;- mean(genetics$breeding_value) # both\n      mean_trait_value[G+1,2] &lt;- sd(genetics$breeding_value) # both\n    }\n    \n    # setup within gen necessities  \n    \n    #Mating_limit_exceeded &lt;- \"NO\" # this will change to YES if a female mates more than 15 times, exceeding the limit we can track \n    \n    # create an empty array to hold female mating times \n    # we assume that females can't mate more than 15 times across the season\n    female_out_times &lt;- matrix(NaN, nrow = popsize, ncol = 15)\n    # and another that holds the male they mated with\n    female_mating_partners &lt;- matrix(NaN, nrow =  popsize, ncol = 15)\n    \n    if(pop[1, 3] &lt; -15){ \n    t &lt;- pop[1, 3] - 0.0001 # start tracking the population just before first emergence\n    } else{t &lt;- -15} # start sim here at the latest\n    \n    alive &lt;- popsize # a stop early condition if everyone dies before the heatwave\n    \n    # we record the OSR at regular intervals\n    next_OSR &lt;- -15 # initial recording\n    \n    OSR &lt;- matrix(NaN, ncol = 2, \n                  nrow = (OSR_recording_interval^-1)*length(next_OSR:heatwave_time))\n    OSR_row &lt;- 1 # keep track of which row to update\n    \n    #event_counter &lt;- 0 # cut eventually\n    \n    while(t &lt; heatwave_time & # the timepoint when the heatwave kills all the adults\n          alive &gt; 0){ # stop early if everyone dies before the heatwave\n      # gillespie through the events, tracking state changes\n      \n      # find individuals out of the mating pool\n      # used to calculate next return to mating pool and death times \n      outfemales &lt;- pop[pop$sex &lt; 1 & is.finite(pop$state),]\n      outmales &lt;- pop[pop$sex &gt; 0 & is.finite(pop$state),]\n      # find individuals in the mating pool \n      # used to find the next potential mating and death times\n      infemales &lt;- pop[pop$sex &lt; 1 & is.na(pop$state),]\n      inmales &lt;- pop[pop$sex &gt; 0 & is.na(pop$state),]\n      \n      # find next event\n      \n      # emergence - remove past and select next one - pre-ordering makes this easy\n      next_emergence &lt;- pop[pop$emergence_time &gt; t, \"emergence_time\"][1]\n      \n      # time in - Inf and NaN are possible options that the code can handle \n      next_time_in &lt;- min(pop$state, na.rm = T)\n      \n      # matings... if rate is 0, NaN produced.\n      pop_matingrate &lt;- v*nrow(infemales)*nrow(inmales)\n      next_mating &lt;- t + rexp(n = 1, rate = pop_matingrate)\n      \n      # death... if rate is 0, NaN produced.\n      death_rate &lt;- \n        mu_f_out*nrow(outfemales) +\n        mu_f_in*nrow(infemales) +\n        mu_m_out*nrow(outmales) +\n        mu_m_in*nrow(inmales)\n      \n      next_death &lt;- t + rexp(n = 1, rate = death_rate)\n      \n      # find the next event and update t\n      t &lt;- pmin(next_emergence,\n                next_time_in,\n                next_mating,\n                next_death,\n                next_OSR,\n                heatwave_time,\n                na.rm = TRUE) # ... if a rate is 0, NaN produced.\n      \n      # record OSR\n      if(t == next_OSR & !is.na(next_OSR)){\n        OSR[OSR_row,1] &lt;- nrow(infemales)\n        OSR[OSR_row,2] &lt;- nrow(inmales)\n        next_OSR &lt;- next_OSR + OSR_recording_interval # record OSR at specified time interval\n        OSR_row &lt;- OSR_row + 1\n      }\n      \n      # update the population by changing the states of individuals\n      \n      # following emergence, initial state depends on sex \n      if(t == next_emergence & !is.na(next_emergence)){\n        # who is it\n        # because ID is ordered by emergence, select first row after filtering out old events\n        emergence_ID &lt;- pop[pop$emergence_time &gt;= t, \"ID\"][1]\n        \n        if(pop[pop$ID == emergence_ID,]$sex &gt; 0){ # if male, find time male enters mating pool\n          pop[emergence_ID, \"state\"] &lt;- get_male_time_in(c_m, t, t0, k)\n        } else{pop[emergence_ID, \"state\"] &lt;- NaN} # if female, start in time-in\n      }\n      \n      # if the next event is a mating\n      if(t == next_mating & !is.na(next_mating)){\n        # see who mates\n        # everyone searches at the same rate \n        # so within sexes, all time-in individuals have the same probability of mating\n        # that means we can randomly sample one female and one male from the mating pool\n        who_mates_female &lt;- sensible_sample(infemales$ID, 1)\n        who_mates_male &lt;- sensible_sample(inmales$ID, 1)\n        # get_female_resource_quantity and calculate refractory period\n        R_f &lt;- get_female_resource_quantity(t, t0, k, s) # use pre-defined function\n        f_refract_period &lt;- R_f*c_f\n        # change state to time-out = real numbers\n        pop[who_mates_female, \"state\"] &lt;- t + f_refract_period\n        pop[who_mates_male, \"state\"] &lt;- get_male_time_in(c_m, t, t0, k)\n        # now update the female LRS table\n        # modify the recorded refractory period if egg-laying gets cut short by heatwave\n        if(f_refract_period + t &gt; heatwave_time){ \n          f_refract_period &lt;- heatwave_time - t\n        }\n        # work out how many past repro bouts the newly mated female has had\n        # ID is the same as row number - females can thus be searched by row number\n        # for a specific row, we need to find the next column that has an NaN value\n        #e.g. if a female has mated 3 times previously, the next NaN will be in column 4\n        repro_bout &lt;- which(is.nan(female_out_times[who_mates_female, ]))[1]\n        # Replace the next NaN in the row that corresponds to the appropriate female\n        female_out_times[who_mates_female, repro_bout] &lt;- f_refract_period\n        female_mating_partners[who_mates_female, repro_bout] &lt;- who_mates_male # record mate\n      }\n      \n      # if the next event is a return to mating pool\n      if(t == next_time_in & !is.na(next_time_in)){\n        # find who it is and change state to time-in\n        pop[which.min(pop$state), \"state\"] &lt;- NaN\n      }\n      \n      # if the next event is a death, who dies\n      if(t == next_death & !is.na(next_death)){\n        who_dies &lt;- NA # make sure this resets\n        out_f_weight &lt;- (mu_f_out*nrow(outfemales))/death_rate\n        in_f_weight &lt;- (mu_f_in*nrow(infemales))/death_rate\n        out_m_weight &lt;- (mu_m_out*nrow(outmales))/death_rate\n        in_m_weight &lt;- (mu_m_in*nrow(inmales))/death_rate\n        # which class does the death come from?\n        death_class &lt;- \n          sensible_sample(c(\"out_f\", \"in_f\", \"out_m\", \"in_m\"),\n                 size = 1, \n                 prob = c(out_f_weight, in_f_weight, out_m_weight, in_m_weight))\n        # all individuals within class have same death rate, choose 1 at random\n        if(death_class == \"out_f\"){\n          who_dies &lt;- sensible_sample(outfemales$ID, 1)\n          # end the egg laying period prematurely\n          repro_bout_mu &lt;- which(is.nan(female_out_times[who_dies, ]))[1] - 1 # find first NA, then go back a col\n          # subtract the time lost due to death from existing refractory period\n          if(pop$state[who_dies] &gt; heatwave_time){\n            female_out_times[who_dies, repro_bout_mu] &lt;- \n              female_out_times[who_dies, repro_bout_mu] - (heatwave_time - t)\n          } else{female_out_times[who_dies, repro_bout_mu] &lt;- \n            female_out_times[who_dies, repro_bout_mu] - (pop$state[who_dies] - t)\n          }\n        }\n        if(death_class == \"in_f\"){\n          who_dies &lt;- sensible_sample(infemales$ID, 1)}\n        if(death_class == \"out_m\"){\n          who_dies &lt;- sensible_sample(outmales$ID, 1)}\n        if(death_class == \"in_m\"){\n          who_dies &lt;- sensible_sample(inmales$ID, 1)}\n        # change state\n        pop[who_dies, \"state\"] &lt;- Inf\n      }\n      \n      # count individuals that haven't died\n      alive &lt;- nrow(pop[pop$state != Inf | pop$emergence_time &gt; t,]) \n      #event_counter &lt;- event_counter + 1\n      #print(paste(\"t =\", round(t, 3), \"event no. =\", event_counter, \n      #           \"no. ind alive =\", alive))\n      \n    } # end within generation while loop\n    \n    # once the season is complete, compute fecundity and male paternity \n    # from this we determine which breeding values are transmitted to the next generation\n    # length of time for each reproductive bout == fecundity \n    \n    matings &lt;- sum(!is.nan(female_out_times)) # if this is zero the sim will quit \n    \n    if(matings &gt; 0){ # if at least one female mated, produce the next generation\n      \n      # find the mothers using our pre-written function\n      mothers &lt;- mother_finder_function(female_out_times, \n                                        popsize)  \n      \n      # find the fathers using our pre-written function\n      fathers &lt;- father_finder_function(mothers, \n                                        female_out_times, \n                                        female_mating_partners,\n                                        sperm_comp_weights)\n      \n      # setup adults in the next generation\n      \n      if(sex_limited &gt; 0){ # two traits need to be tracked\n        next_gen &lt;- \n          cbind(as.data.frame(mothers), as.data.frame(fathers)) %&gt;%\n          merge(genetics, by.x = \"mothers\", by.y = \"ID\") %&gt;% \n          merge(genetics, by.x = \"fathers\", by.y = \"ID\",\n                suffixes = c(\".mother\", \".father\")) %&gt;% \n          mutate(f_limited_bv = (f_limited_bv.mother + f_limited_bv.father)/2 +\n                   rnorm(popsize, mean = 0, sd = genome_wide_mutation),\n                 m_limited_bv = (m_limited_bv.mother + m_limited_bv.father)/2 +\n                   rnorm(popsize, mean = 0, sd = genome_wide_mutation),\n                 sex = rbinom(popsize, 1, prob = 0.5), # 0 is female, +1 is male\n                 state = Inf,\n                 p = runif(popsize), \n                 # get emergence times\n                 emergence_time = \n                   case_when(sex &gt; 0 ~ emergence_sample(m_limited_bv, p),\n                             sex &lt; 1 ~ emergence_sample(f_limited_bv, p))) %&gt;%\n          arrange(emergence_time) %&gt;% # order by emergence time to streamline later operations\n          mutate(ID = 1:popsize) # set ID for each individual\n        \n        # get the two tables we need to run the next generation\n        pop &lt;-\n          next_gen %&gt;% \n          select(sex, state, emergence_time, ID) # remove un-needed columns\n        \n        genetics &lt;- \n          next_gen %&gt;% \n          select(ID, f_limited_bv, m_limited_bv)\n      } else{ # one trait needs to be tracked \n        next_gen &lt;- \n          cbind(as.data.frame(mothers), as.data.frame(fathers)) %&gt;%\n          merge(genetics, by.x = \"mothers\", by.y = \"ID\") %&gt;% \n          merge(genetics, by.x = \"fathers\", by.y = \"ID\",\n                suffixes = c(\".mother\", \".father\")) %&gt;% \n          mutate(breeding_value = (breeding_value.mother + breeding_value.father)/2 +\n                   rnorm(popsize, mean = 0, sd = genome_wide_mutation),\n                 sex = rbinom(popsize, 1, prob = 0.5), # 0 is female, +1 is male\n                 state = Inf,\n                 p = runif(popsize), \n                 # get emergence times\n                 emergence_time = emergence_sample(breeding_value, p)) %&gt;%\n          arrange(emergence_time) %&gt;% # order by emergence time to streamline later operations\n          mutate(ID = 1:popsize) # set ID for each individual\n        \n        # get the two tables we need to run the next generation\n        pop &lt;-\n          next_gen %&gt;% \n          select(sex, state, emergence_time, ID) # remove un-needed columns\n        \n        genetics &lt;- \n          next_gen %&gt;% \n          select(ID, breeding_value)\n      }\n    } \n    # record OSR across season\n    OSR_list[[G+1]] &lt;- OSR\n    \n    \n    # update the generation counter \n    G &lt;- G + 1\n    \n    # loop back to top of while loop...\n  }\n  \n  results &lt;- list(mean_trait_value, OSR_list)\n  \n  results\n}"
  },
  {
    "objectID": "simulation.html#run-the-simulation",
    "href": "simulation.html#run-the-simulation",
    "title": "Simulation",
    "section": "Run the simulation",
    "text": "Run the simulation\nRun the simulation for 5000 generations, for a single set of parameters.\nThose parameters are:\n\n\nCode\nparameters_test &lt;- \n  expand_grid(popsize = 1000,\n              mu_f_in = 0.1,\n              mu_f_out = 0.1,\n              mu_m_in = 0.1,\n              mu_m_out = 0.1,\n              v = 8/(popsize / 2), # rate searching sex finds other sex\n              c_m = 0.5, # min time to regen spermatophore\n              c_f = 0.5,\n              s = 0.25, # spermatophore boost\n              t0 = 0, # 50% resources at time 0\n              k = 0.5,\n              genome_wide_mutation = 0.2, # sd for normal with mu = 0\n              heatwave_time = 0, # when are all the adults killed each year\n              gens = 5000)\n\nglimpse(parameters_test)\n\n\nRows: 1\nColumns: 14\n$ popsize              &lt;dbl&gt; 1000\n$ mu_f_in              &lt;dbl&gt; 0.1\n$ mu_f_out             &lt;dbl&gt; 0.1\n$ mu_m_in              &lt;dbl&gt; 0.1\n$ mu_m_out             &lt;dbl&gt; 0.1\n$ v                    &lt;dbl&gt; 0.016\n$ c_m                  &lt;dbl&gt; 0.5\n$ c_f                  &lt;dbl&gt; 0.5\n$ s                    &lt;dbl&gt; 0.25\n$ t0                   &lt;dbl&gt; 0\n$ k                    &lt;dbl&gt; 0.5\n$ genome_wide_mutation &lt;dbl&gt; 0.2\n$ heatwave_time        &lt;dbl&gt; 0\n$ gens                 &lt;dbl&gt; 5000\n\n\n\n\nCode\nif(file.exists(\"results/test.rds\")){test &lt;- read_rds(\"results/test.rds\")\n}else{test &lt;-\n  main_sim(row = 1,\n           input = parameters_test,\n           sex_limited = 1,\n           OSR_recording_interval = 0.5,\n           sperm_competition_weightings = sperm_mixing_weights)\nwrite_rds(test, \"results/test.rds\")\n}\n\n\nRun the simulation for a 1,000 generations, for many combinations of parameters. To do this, we make use of the parallel package, which allows us to split the simulation effort across multiple cores.\nFor testing, I’ve first included code for running the simulation on a single core\n\n\nCode\nlapply(1:10, # rows to run\n       main_sim,\n       input = parameter_space,\n       sex_limited = 1,\n       OSR_recording_interval = 0.5,\n       sperm_competition_weightings = sperm_mixing_weights)\n\n\n\n\nCode\n# split parameter space up\n\nspace_1 &lt;- parameter_space[1:100,]\nspace_2 &lt;- parameter_space[101:200,]\nspace_3 &lt;- parameter_space[201:300,]\nspace_4 &lt;- parameter_space[301:400,]\nspace_5 &lt;- parameter_space[401:500,]\nspace_6 &lt;- parameter_space[501:600,]\nspace_7_10 &lt;- parameter_space[601:1000,]\n#space_8 &lt;- parameter_space[701:800,]\n#space_9 &lt;- parameter_space[801:900,]\n#space_10 &lt;- parameter_space[901:1000,]\nspace_11 &lt;- parameter_space[1001:1100,]\nspace_12 &lt;- parameter_space[1101:1200,]\nspace_13 &lt;- parameter_space[1201:1300,]\nspace_14 &lt;- parameter_space[1301:1400,]\nspace_15 &lt;- parameter_space[1401:1500,]\n\nif(!file.exists(\"results/complete_results_7_10.rds\")){\n  \n  # get the number of cores on the computer \n  n.cores &lt;- parallel::detectCores()\n  \n  # make the cluster\n  cluster &lt;- parallel::makeCluster(n.cores)\n  \n  # split parameters across cluster and import required functions and libraries\n  \n  parallel::clusterEvalQ(cluster, c(library(dplyr)))\n  \n  parallel::clusterExport(cluster, c(\"space_7_10\",\n                                     \"emergence_sample\",\n                                     \"mother_finder_function\",\n                                     \"father_finder_function\",\n                                     \"get_female_resource_quantity\",\n                                     \"get_male_time_in\",\n                                     \"sensible_sample\"))\n  \n  results &lt;- parallel::parLapply(cluster,\n                      1:nrow(space_7_10),\n                      main_sim,\n                      input = space_7_10,\n                      sex_limited = 1,\n                      OSR_recording_interval = 0.5,\n                      sperm_competition_weightings = sperm_mixing_weights)\n  write_rds(results, \"results/complete_results_7_10.rds\")\n}\n\n\nLoad the results\n\n\nCode\nresults_1 &lt;- read_rds(\"results/complete_results_1.rds\")\nresults_2 &lt;- read_rds(\"results/complete_results_2.rds\")\nresults_3 &lt;- read_rds(\"results/complete_results_3.rds\")\nresults_4 &lt;- read_rds(\"results/complete_results_4.rds\")\nresults_5 &lt;- read_rds(\"results/complete_results_5.rds\")\nresults_6 &lt;- read_rds(\"results/complete_results_6.rds\")\nresults_7_10 &lt;- read_rds(\"results/complete_results_7_10.rds\")"
  },
  {
    "objectID": "simulation.html#plotting-a-single-example",
    "href": "simulation.html#plotting-a-single-example",
    "title": "Simulation",
    "section": "Plotting a single example",
    "text": "Plotting a single example\n\nThe evolution of protandry across many generations\n\n\nCode\nplotting_data &lt;-\n  test[1] %&gt;% \n  as.data.frame() %&gt;% \n  as_tibble() %&gt;% \n  rename(Female_mu = X1,\n         Female_sd = X2,\n         Male_mu = X3,\n         Male_sd = X4) %&gt;% \n  mutate(Generation = 0:5000) %&gt;% \n  pivot_longer(cols = 1:4, names_to = \"cat\", values_to = \"emergence_time\") %&gt;% \n  separate(cat, into = c(\"Sex\", \"Measure\"), sep = \"_\") %&gt;% \n  pivot_wider(names_from = Measure, values_from = emergence_time) \n\np1&lt;-\n  plotting_data %&gt;% \n  ggplot(aes(x = Generation, y = mu, group = Sex, colour = Sex)) +\n  geom_line() +\n  scale_colour_manual(values = c(pnw_palette(\"Sunset2\", n = 5)[2],\n                                 pnw_palette(\"Sunset2\", n = 5)[4])) +\n  scale_x_continuous(limits = c(0,5000)) +\n  labs(y = \"Mean emergence time breeding value\",\n       colour = \"Sex\") +\n  theme_bw() +\n  theme(legend.position = \"bottom\")\n\np2&lt;-\n  plotting_data %&gt;% \n  ggplot(aes(x = Generation, y = sd, group = Sex, colour = Sex)) +\n  geom_line(alpha = 0.8) +\n  scale_colour_manual(values = c(pnw_palette(\"Sunset2\", n = 5)[2],\n                                 pnw_palette(\"Sunset2\", n = 5)[4])) +\n  scale_x_continuous(limits = c(0,5000)) +\n  scale_y_continuous(limits = c(0,1)) +\n  labs(y = \"Standard deviation in emergence breeding value\",\n       colour = \"Sex\") +\n  theme_bw() +\n  theme(legend.position = \"bottom\")\n\np1 / p2 + plot_layout(axis_titles = \"collect\")\n\n\n\n\n\n\n\n\n\n\n\nThe evolution of the OSR across many generations\n\n\nCode\nOSR_data &lt;-\n  test[2] %&gt;% \n  as.data.frame() %&gt;% \n  as_tibble() %&gt;% \n  mutate(Time = seq(from = -15, to = 0.5, by = 0.5)) %&gt;% \n  pivot_longer(cols = !last_col(), \n               names_to = \"class\", \n               values_to = \"Individuals\") %&gt;% \n  separate(class, into = c(\"place\", \"generation\"), sep = \"\\\\.\") %&gt;% \n  mutate(sex = case_when(str_detect(place, \"X1\") ~ \"Female\",\n                         .default = \"Male\"),\n         generation = if_else(is.na(generation), \"0\", generation),\n         generation = as.numeric(generation)) %&gt;%\n  select(-place) %&gt;% \n  filter(Time != 0.5) %&gt;% \n  pivot_wider(names_from = sex, values_from = Individuals)\n\npal&lt;-pnw_palette(\"Shuksan2\",20)\n\nOSR_data %&gt;% \n  mutate(OSR = Male / (Male + Female)) %&gt;% \n  mutate(resources = 1/(1 + exp(-0.5*(Time - (0))))) %&gt;% \n  filter(generation == 0 |\n           generation == 100 |\n           generation == 200 |\n           generation == 300 |\n           generation == 400 |\n           generation == 500 |\n           generation == 600 |\n           generation == 700 |\n           generation == 800 |\n           generation == 900 |\n           generation == 1000 |\n           generation == 1100 |\n           generation == 1200 |\n           generation == 1300 |\n           generation == 1400 |\n           generation == 1500 |\n           generation == 1600 |\n           generation == 1700 |\n           generation == 1800 |\n           generation == 1900 |\n           generation == 2000) %&gt;% \n  ggplot(aes(x = Time, y = OSR, \n             group = generation, colour= generation)) +\n  #geom_point()+\n  geom_smooth(se = FALSE) +\n  geom_line(aes(y = resources), colour = \"black\", linetype =2) +\n  labs(y = \"OSR (prop. males in mating pool)\",\n       colour = \"Generation\") +\n  scale_colour_gradientn(colours = pal) +\n  theme_bw()"
  },
  {
    "objectID": "simulation.html#full-results",
    "href": "simulation.html#full-results",
    "title": "Simulation",
    "section": "Full results",
    "text": "Full results\n\n\nCode\nresults_processer &lt;- \n  function(row, results){\n    tibble(female_mean = results[[row]][[1]][1000,1],\n           male_mean = results[[row]][[1]][1000,3],\n           parameter_space_ID = row)\n  }\n\nwrangled_results_1 &lt;- \n  map_dfr(1:nrow(space_1), results_processer, results_1) %&gt;% \n  bind_cols(space_1)\n\nwrangled_results_2 &lt;- \n  map_dfr(1:nrow(space_2), results_processer, results_2) %&gt;% \n  bind_cols(space_2)\n\nwrangled_results_3 &lt;- \n  map_dfr(1:nrow(space_3), results_processer, results_3) %&gt;% \n  bind_cols(space_3)\n\nwrangled_results_4 &lt;- \n  map_dfr(1:nrow(space_4), results_processer, results_4) %&gt;% \n  bind_cols(space_4)\n\nwrangled_results_5 &lt;- \n  map_dfr(1:nrow(space_5), results_processer, results_5) %&gt;% \n  bind_cols(space_5)\n\nwrangled_results_6 &lt;- \n  map_dfr(1:nrow(space_6), results_processer, results_6) %&gt;% \n  bind_cols(space_6)\n\nwrangled_results_7_10 &lt;- \n  map_dfr(1:nrow(space_7_10), results_processer, results_7_10) %&gt;% \n  bind_cols(space_7_10)\n\nwrangled_results &lt;-\n  bind_rows(wrangled_results_1,\n            wrangled_results_2,\n            wrangled_results_3,\n            wrangled_results_4,\n            wrangled_results_5,\n            wrangled_results_6,\n            wrangled_results_7_10)\n\n\nPlot\n\n\nCode\nheat_map_protandry &lt;-\n  wrangled_results %&gt;% \n  filter(s != 0.1) %&gt;% \n  ggplot(aes(x = c_f/c_m, y = heatwave_time)) +\n  geom_raster(aes(fill = female_mean - male_mean)) +\n  scale_fill_gradientn(colours = pal, limits=c(0,5)) +\n  facet_wrap(~ s, nrow = 1,\n             labeller = label_glue('Spermatophore value: {`s`}')) +\n  labs(x = \"Female max time-out / Male max time-out\",\n       y = \"Time of heatwave\\n(length of prosperity)\",\n       fill = \"Protandry\") +\n  scale_x_continuous(expand = c(0, 0), \n                     breaks = c(3, 6, 9, 12, 15)) + \n  scale_y_continuous(expand = c(0, 0)) + \n  theme(panel.border = element_rect(fill = NA, colour = \"black\", size = .8),\n        strip.background = element_rect(colour = \"black\", fill = \"Aliceblue\", linewidth = .8),\n        strip.text = element_text(size = 12),\n        axis.title.x = element_text(size = 16),\n        axis.title.y = element_text(size = 16),\n        axis.text = element_text(size = 12))\n\npanel_1 / heat_map_protandry"
  }
]